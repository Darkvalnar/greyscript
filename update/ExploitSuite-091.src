// this is the Rawlings Exploit Suite, basically a hacked together multitool

// Able to probe, attack remote target, attack router, attack locally, crack wifi and check libraries for exploits and check library versions

// Rawlings Exploit Suite currently running at:
suiteversion = "0.9.1"
// starting cosmetics setup here
line = "--------------------"
line1 = "***##########################################################################################################################***"
print(line1)
print("
███████ ██   ██ ██████  ██       ██████  ██ ████████ ███████ ██    ██ ██ ████████ ███████ 
██       ██ ██  ██   ██ ██      ██    ██ ██    ██    ██      ██    ██ ██    ██    ██      
█████     ███   ██████  ██      ██    ██ ██    ██    ███████ ██    ██ ██    ██    █████   
██       ██ ██  ██      ██      ██    ██ ██    ██         ██ ██    ██ ██    ██    ██      
███████ ██   ██ ██      ███████  ██████  ██    ██    ███████  ██████  ██    ██    ███████ 
                                                                                          
                                                                                          
██████  ██    ██     ██████   █████  ██     ██ ██      ██ ███    ██  ██████  ███████      
██   ██  ██  ██      ██   ██ ██   ██ ██     ██ ██      ██ ████   ██ ██       ██           
██████    ████       ██████  ███████ ██  █  ██ ██      ██ ██ ██  ██ ██   ███ ███████      
██   ██    ██        ██   ██ ██   ██ ██ ███ ██ ██      ██ ██  ██ ██ ██    ██      ██      
██████     ██        ██   ██ ██   ██  ███ ███  ███████ ██ ██   ████  ██████  ███████      
                                                                                          
                                                                                          
 █████  ███    ██ ██████      ███████ ████████  ██████  ██████  ███████ ███████ ███    ██ 
██   ██ ████   ██ ██   ██     ██         ██    ██    ██ ██   ██ ██      ██      ████   ██ 
███████ ██ ██  ██ ██   ██     ███████    ██    ██    ██ ██████  █████   █████   ██ ██  ██ 
██   ██ ██  ██ ██ ██   ██          ██    ██    ██    ██ ██      ██      ██      ██  ██ ██ 
██   ██ ██   ████ ██████      ███████    ██     ██████  ██      ██      ███████ ██   ████ ")
print(line1)

print("Your almost all-in one suite for exploits.")

print("Current version running: [ <b>" + suiteversion + "</b> ]")
print(line1)
metaxploit = include_lib("/lib/metaxploit.so")
// fetch metaxploit lib

if not metaxploit then
	currentPath = get_shell.host_computer.current_path
	metaxploit = include_lib(currentPath + "/metaxploit.so")

	// work around if library not in libs folder

end if

cryptools = include_lib("/lib/crypto.so")

if not cryptools then
	exit("Error: Missing crypto library")
end if

inmenu = "1"
menu = "0"
// show a menu to select the desired operation from.

// will be within a while block in the future, so you can return to the main menu after executing an operation

// if you so wish

selection = "0"

mainmenu = function(menu)
	if inmenu == "1" and menu == "0" then
		print(("Possible operations (Select number to start)"))

		print(("<b>  1.)</b> Target probing\n <b> 2.)</b> Library version check (locally)\n <b> 3.)</b> Library vulnerability scan\n <b> 4.)</b> Remote attack\n <b> 5.)</b> Local attack\n <b> 6.)</b> Attack Router\n <b> 7.)</b> Crack Wifi \n <b> 8.)</b> Decrypt Local Bank Info \n "))

		selection = user_input("> ")
		menuselect(selection)
	end if

end function

// probing script starts here 

menuselect = function(selection)
	//inmenu = "0"

	if selection == "1" then
		print(line)
		print("Probe your target!")
		print(line)

		print("Specify target type...")

		target = user_input("Website? Y/N > ")

		if target == "Y" or target == "y" then
			domain = user_input("Domain > ")
			ip = nslookup(domain)
			//since we can not directly probe domains, we need to first convert the domain to IP and then store it in a variable
			print("Probing " + ip + "............")
			print("Divide et impera")
			router = get_router(ip)
			// fetch the router 
			ports = router.used_ports
			// fetch all ports used on router
			print(("Probe Complete - Open Ports:"))
			print((line))

			if not ports then
				print("PORTS NOT FOUND.....")
			end if

			//<----questionable, but included

			for port in ports
				print("Port#: " + port.port_number + " - " + router.port_info(port) + " Server")
				//<---- print our result
				print((line))
			end for

			print((line))
			user_input("Press any key to return to menu")
			menu = "0"
			mainmenu(menu)
		else
			ip = user_input("Target IP > ")
			print("Probing " + ip + "............")
			print("Divide et impera")

			if not is_valid_ip(ip) then
				exit(("Probe Failed: Invalid IP"))
			end if

			//check if the IP is in fact a valid IP, if not, we get prompted it's not valid

			router = get_router(ip)
			// fetch routher

			if not router then
				exit("Probe Failed: Unable to find specified router")

			end if

			// check if we can find a router with the IP

			ports = router.used_ports
			// fetch all ports used on router
			print(("Probe Complete - Open Ports:"))
			print((line))

			if not ports then
				print("PORTS NOT FOUND.....")
			end if

			// check if we can find any ports on the IP

			for port in ports
				// loop to continiously look for ports

				print("Port#: " + port.port_number + " - " + router.port_info(port) + " Server")
				// print our result
			end for

			// break up the loop here
			print((line))
			user_input("Press any key to return to menu")
			menu = "0"
			mainmenu(menu)
		end if

	end if

	// library version checker

	if selection == "2" then
		checkinputOK = false

		while (not checkinputOK)
			print(line)
			print("Running library version checker")
			print(line)
			libtoscan = user_input("Which library to scan? (ssh, smtp, http, ftp, sql, init, net, kernel) > ")
			libtoscan = libtoscan.replace("ssh", "/lib/libssh.so")
			libtoscan = libtoscan.replace("smtp", "/lib/libsmtp.so")
			libtoscan = libtoscan.replace("http", "/lib/libhttp.so")
			libtoscan = libtoscan.replace("ftp", "/lib/libftp.so")
			libtoscan = libtoscan.replace("sql", "/lib/libsql.so")
			libtoscan = libtoscan.replace("init", "/lib/init.so")
			libtoscan = libtoscan.replace("net", "/lib/net.so")
			libtoscan = libtoscan.replace("kernel", "/lib/kernel_module.so")
			metaLib = metaxploit.load(libtoscan)
			file = get_shell.host_computer.File(libtoscan)

			// if not, you're fucked

			if file == null then
				print((libtoscan + " : " + "No such file or directory"))
			else
				scanresult = metaLib.version
				print("Version is: " + scanresult)
				var_ran_qwe = user_input("Check more library versions? Y/N > ")
				if var_ran_qwe == "N" or var_ran_qwe == "n" then
					checkinputOK = true
					print((line))
					user_input("Press any key to return to menu")
					menu = "0"
					mainmenu(menu)
				else
					checkinput = null
				end if

			end if

		end while
	end if

	// library vulnerability scan

	if selection == "3" then
		print(line)

		print("Scan for vulnerabilities in a specified library!")

		print(line)
		scanlibs = user_input("Which library to scan? (ssh, smtp, http, ftp, sql, init, net, kernel) > ")
		scanlibs = scanlibs.replace("ssh", "/lib/libssh.so")
		scanlibs = scanlibs.replace("smtp", "/lib/libsmtp.so")
		scanlibs = scanlibs.replace("http", "/lib/libhttp.so")
		scanlibs = scanlibs.replace("ftp", "/lib/libftp.so")
		scanlibs = scanlibs.replace("sql", "/lib/libsql.so")
		scanlibs = scanlibs.replace("init", "/lib/init.so")
		scanlibs = scanlibs.replace("net", "/lib/net.so")
		scanlibs = scanlibs.replace("kernel", "/lib/kernel_module.so")
		print("Trying to fetch " + scanlibs)

		// check if we have the target library

		file = get_shell.host_computer.File(scanlibs)

		// if not, you're fucked

		if file == null then
			print((scanlibs + " : " + "No such file or directory"))
		else
			metaLib = metaxploit.load(scanlibs)
			// load our target library with file path as library to scan within metaxploit
			listMem = metaxploit.scan(metaLib)
			// start listing vulnerable  memory addresses
			print(("Scanning memory adress....."))
			index = 1

			for itemMem in listMem
				// for loop to actually keep checking for exploitable adresses

				print((index + ": [" + itemMem + "]"))
				index = index + 1
			end for

			// stop (for loop) right there criminal scum

		end if

		print(("Completed scan. Detected vulnerabilities in " + listMem.len + " memory zones."))
		// list the exploitable addresses within library's memory
		option = ""
		inputOK = false
		// we set input variable to null

		while (not inputOK)
			// defaults to 0
			option = user_input("Pick the memory index to check: ").to_int

			// if your input exceeds the listed memory, isn't a number or is less than 1, ask for new input

			if typeof(option) != "number" or (option < 1 or option > listMem.len) then
				print(("Input invalid. Did you type a valid number?"))
			else
				// if it is within valid range, start printing exploitable values for respective adress

				print("Scanning for vulnerabilities in: " + listMem[option - 1])

				print(metaxploit.scan_address(metaLib, listMem[option - 1]))
				var_ran_qwe = user_input("Continue scanning? Y/N >")
				if var_ran_qwe == "N" or var_ran_qwe == "n" then
					checkinputOK = true
					print((line))
					user_input("Press any key to return to menu")
					menu = "0"
					mainmenu(menu)
				else
					checkinput = null
				end if
			end if

		end while

	end if

	// start everything in order, except library check. First we probe for ports/services:

	if selection == "4" then
		print(line)
		print("Preparing attack sequence...")
		print(line)

		print("Specify target type...")

		target = user_input("Website? Y/N > ")

		if target == "Y" or target == "y" then
			domain = user_input("Domain > ")
			ip = nslookup(domain)
			//since we can not directly probe domains, we need to first convert the domain to IP and then store it in a variable
			print("Probing " + ip + "............")
			print("Divide et impera")
			router = get_router(ip)
			// fetch the router 
			ports = router.used_ports
			// fetch all ports used on router
			print(("Probe Complete - Open Ports:"))
			print((line))

			if not ports then
				print("PORTS NOT FOUND.....")
			end if

			//<----questionable, but included

			for port in ports
				print("Port#: " + port.port_number + " - " + router.port_info(port) + "Server")
				//<---- print our result
			end for

			print((line))
		end if

		if target == "N" or target ==  "n" then
			ip = user_input("Target IP: ")
			print("Probing " + ip + "............")
			print("Divide et impera")

			if not is_valid_ip(ip) then
				exit(("Probe Failed: Invalid IP"))
			end if

			//check if the IP is in fact a valid IP, if not, we get prompted it's not valid

			router = get_router(ip)
			// fetch routher

			if not router then
				exit("Probe Failed: Unable to find specified router")

			end if

			// check if we can find a router with the IP

			ports = router.used_ports
			// fetch all ports used on router
			print(("Probe Complete - Open Ports:"))
			print((line))

			if not ports then
				print("PORTS NOT FOUND.....")
			end if

			// check if we can find any ports on the IP

			for port in ports
				// loop to continiously look for ports

				print("Port#: " + port.port_number + " - " + router.port_info(port))
				// print our result
			end for

			// break up the loop here
			print((line))
		end if

		option = ""
		inputisOK = null

		while inputisOK == null
			option = user_input("Port to attack > ").to_int
			print(("Acquired port: " + option + " to attack"))
			portcheck = user_input("Is this port correct? (Y/N) > ")
			// did we select the right port?

			if portcheck == "N" or portcheck == "n" then
				print(("Pick another port"))
			else
				attackport = option
				inputisOK = true

				// we are storing the selected port for the actual attack

			end if

		end while

		print(("Attempting to establish net session"))
		print(line)
		net_session = metaxploit.net_use(ip, attackport)

		if not net_session then
			exit("Error: can't connect to net session")
		end if

		metaLib = net_session.dump_lib
		print((line))
		print(("Net session established"))
		print((line))

		passinject = user_input("Specify password for possible inject > ")

		quit = function(shell, pass)
			print("Password for root:")

			get_shell.launch("/bin/crack", pass)
			shell.start_terminal
		end function

		shell = null
		pass = null
		memory = metaxploit.scan(metaLib)

		for mem in memory
			address = metaxploit.scan_address(metaLib, mem).split("Unsafe check:")

			for add in address
				if add == address[0] then
					continue
				end if

				if shell and pass then
					quit(shell, pass)
				end if

				value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
				value = value.replace("\n", "")
				result = metaLib.overflow(mem, value, passinject)
				print(typeof(result)+": "+result)

				if typeof(result) != "shell" and typeof(result) != "computer" then
					continue
				end if

				if typeof(result) == "shell" then
					shell = result
					comp = result.host_computer
				end if

				if typeof(result) == "computer" then
					comp = result
				end if

				file = comp.File("/etc/passwd")
				print(typeof(file))
				if not file and file.has_permission("r") then
					continue
				end if

				cont = file.get_content

				if not cont then
					continue
				end if

				pass = cont.split("\n")[0]

				if shell then
					quit(shell, pass)
				end if

			end for
		end for

		if shell then
			shell.start_terminal
		end if

		exit(("Attack failed"))
	end if

	// local attack scan

	if selection == "5" then
		print(line)
		print("Running local attack with memory vulnerability scan")
		print(line)
		liblocal = user_input("Which library to attack? init, net, kernel >")
		liblocal = liblocal.replace("init", "/lib/init.so")
		liblocal = liblocal.replace("net", "/lib/net.so")
		liblocal = liblocal.replace("kernel", "/lib/kernel.so")
		print("Trying to fetch " + liblocal)

		// check if we have the target library

		file = get_shell.host_computer.File(liblocal)

		// if not, you're fucked

		if file == null then
			print((liblocal + " : " + "No such file or directory"))
		else
			metaLib = metaxploit.load(liblocal)
			// load our target library with file path as library to scan within metaxploit

			passinject = user_input("Specify password for possible inject > ")

			quit = function(shell, pass)
				print("Password for root:")

				get_shell.launch("/bin/crack", pass)
				shell.start_terminal
			end function

			shell = null
			pass = null
			memory = metaxploit.scan(metaLib)

			for mem in memory
				address = metaxploit.scan_address(metaLib, mem).split("Unsafe check:")

				for add in address
					if add == address[0] then
						continue
					end if

					if shell and pass then
						quit(shell, pass)
					end if

					value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
					value = value.replace("\n", "")
					result = metaLib.overflow(mem, value, passinject)

					if typeof(result) != "shell" and typeof(result) != "computer" then
						continue
					end if

					if typeof(result) == "shell" then
						shell = result
					end if

					if typeof(result) == "shell" then
						comp = result.host_computer
					end if

					if typeof(result) == "computer" then
						comp = result
					end if

					file = comp.File("/etc/passwd")

					if not file then
						continue
					end if

					cont = file.get_content

					if not cont then
						continue
					end if

					pass = cont.split("\n")[0]

					if shell then
						quit(shell, pass)
					end if

				end for
			end for

			if shell then
				shell.start_terminal
			end if

			exit(("Attack failed"))
		end if

	end if

	//router attack 

	if selection == "6" then
		ip = user_input("Enter IP: ")
		print(("Attempting to establish net session"))
		net_session = metaxploit.net_use(ip)

		if not net_session then
			exit("Error: can't connect to net session")
		end if

		lanIP = user_input("Enter LAN address: ")
		libKernel = net_session.dump_lib
		print((line))
		print(("Net session established"))
		print((line))

		passinject = user_input("Specify password for possible inject > ")

		quit = function(shell, pass)
			print("Password for root:")

			get_shell.launch("/bin/crack", pass)
			shell.start_terminal
		end function

		shell = null
		pass = null
		memory = metaxploit.scan(libKernel)

		for mem in memory
			address = metaxploit.scan_address(libKernel, mem).split("Unsafe check:")

			for add in address
				if add == address[0] then
					continue
				end if

				if shell and pass then
					quit(shell, pass)
				end if

				value = add[add.indexOf("<b>") + 3 : add.indexOf("</b>")]
				value = value.replace("\n", "")
				result = libKernel.overflow(mem, value, lanIP)

				if typeof(result) != "shell" and typeof(result) != "computer" then
					continue
				end if

				if typeof(result) == "shell" then
					shell = result
				end if

				if typeof(result) == "shell" then
					comp = result.host_computer
				end if

				if typeof(result) == "computer" then
					comp = result
				end if

				file = comp.File("/etc/passwd")

				if not file then
					continue
				end if

				cont = file.get_content

				if not cont then
					continue
				end if

				pass = cont.split("\n")[0]

				if shell then
					quit(shell, pass)
				end if

			end for
		end for

		if shell then
			shell.start_terminal
		end if

		exit(("Attack failed"))
	end if

	// wifi cracker implementation

	if selection == "7" then
		print(line)
		print("Loading up WiFi cracker")
		print(line)
		crypto = include_lib("/lib/crypto.so")
		// load up crypto with library

		// check if we  can fetch it from somewhere else..

		if not crypto then
			crypto = include_lib("crypto.so")

			if not crypto then
				exit("Missing crypto library, shutting down operation")
			end if
		end if

		// declare our own computer and the interface, takes eth0 by default, will be updated for dynamic use if we can have more than one interface.

		hostPC = get_shell.host_computer
		interface = "eth0"

		if not crypto.airmon("start", interface) then
			exit(("Can not start monitoring on " + interface))
		end if

		print("Targets found.")
		print(line)

		networks = hostPC.wifi_networks(interface)

		if not networks then
			exit("Unable to fetch networks list...")
		end if

		// show potential targets
		print("Available networks:")
		print("#       BSSID            ESSID Strength")
		i = 1

		//for loop to split certaing things of the WifI networks up

		for network in networks
			split = network.split(" ")
			bssid = split[0]
			strength = split[1]
			essid = split[2]
			print(line)
			print(i + ": <b>aireplay -b " + bssid + " -e " + essid + "</b> (" + strength + ")")
			i = i + 1
		end for

		// slect our target to crack
		networkToCrack = "0"
		netprompt = "Select the network you want to target, from 1 to " + networks.len + ":"

		while networkToCrack.val >= network.len or networkToCrack <= 0
			networkToCrack = user_input(netprompt)
		end while

		print(line)
		// start dirty workaround until we can actually automate ACK capturing...
		networkToCrack = networkToCrack.val - 1
		user_input("Locking on network. Use <b>aireplay</b> in another terminal window to capture at least 7000 ACKs, when done, close the other terminal window and hit enter in this one.")
		// end dirty workaround when user inputs something

		if not crypto.airmon("stop", interface) then
			exit("Unable to stop monitoring on " + interface)
		end if

		print("Monitoring stopped")
		print(line)
		capfilepath = home_dir + "/file.cap"
		// store our cap file's path 
		capfile = hostPC.File(capfilepath)

		// store the actual cap file for use with automation below

		if not capfile then
			exit("Cap file is missing. Did you run aireplay?")
		end if

		//  check if cap file is missing

		if not capfile.has_permission("r") then
			exit("Insufficient permission to open cap file for reading.")

		end if

		// check if we have permission to read the actual file

		key = crypto.aircrack(capfilepath)
		// storing the password created from the capfile

		//  check if we were even able to fetch the key

		if not key then
			exit("Could not crack key. Have you obtained enough ACKs and aireplayed the correct network?")
		end if

		print("Password cracked! [ <b>" + key + "</b> ]")

		// displays the stored password if we got a key

		print("Key cracked.")
		print(line)
		split = networks[networkToCrack].split(" ")
		bssid = split[0]
		essid = split[2]

		status = hostPC.connect_wifi(interface, bssid, essid, key)

		// connect to cracked network with all information obtained previously

		print("Connecting to network " + essid)
		// display which WiFi we are connecting to

		// check if we are connected,

		if status == 1 then
			print("Connected successfully. Have fun!")
		else
			print("Connection failed.")
		end if

		capfile.delete
		// yeet the cap file away, it is not necessary anymore after this operation is done.
	end if

	// git dat m0n3y boi

	if selection == "8" then
		line = "--------------------"
		us = active_user

		if us != "root" then
			print("Run suite as root and try again...")
			menu = "0"
			mainmenu(menu)
		else
			print(("git dat m0n3y boi."))
			print(line)
			victim = get_shell.host_computer
			home = victim.File("/home")

			// check for all home folders

			guest = victim.File("/home/guest")
			// does guest exist?

			if guest != null then
				get_shell.launch("/bin/rmdir", "/home/guest")
			end if

			// if it does, TOO BAD, IT'S GONE

			users = home.get_folders
			// we now store all the folders in home as the usernames

			for user in users
				// for loop that will take care of fetching all bank files and decrypting their contents

				bank = victim.File("/home/" + user.name + "/Config/Bank.txt")

				// store all contents of every Bank.txt for each user

				bankfile = ("/home/" + user.name + "/Config/Bank.txt")
				splitted = bank.get_content.split(":")
				// we split the contents of each bank.txt by the character : and store it in splitted
				print((bankfile + " : " + splitted))
				// now we print each path and the contents of splitted

				// if we have cryptools on the target, might as well use it

				if cryptools then
					m0n3y = cryptools.decipher(splitted[0], splitted[1])
					// since we split every bank.txt entry earlier, we can now pass these as separate params to the decrypt
					print((m0n3y))
					// we print the decrypted result and should now be able to get that money BOI
				else

				end if

			end for

		end if

	end if

end function

mainmenu(menu)
