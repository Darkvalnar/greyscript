// this is the Rawlings Exploit Suite, basically a hacked together multitool
// Includes nmap with a Hacknet flair, a local lib version checker, a scanlib and an attack sequence
// The attack sequences first probes a potential target, then checks for vulnerabilites within the targeted service and then runs the exploit
// In 0.5 will also include a more streamlined menu navigation after executing the individual tasks

// Most shit here is also available as a standalone tool.
// I thought about having this as the main thing and then let it launch the standalones tools but nah


// Rawlings Exploit Suite currently running at:
suiteversion = "0.4"

// starting cosmetics setup here
line = "--------------------"
line1 = "***##########################################################################################################################***"  
print(line1)
print("                  ________   _______  _      ____ _____ _______    _____ _    _ _____ _______ ______  ")
print("                 |  ____\ \ / /  __ \| |    / __ \_   _|__   __|  / ____| |  | |_   _|__   __|  ____|")
print("                 | |__   \ V /| |__) | |   | |  | || |    | |    | (___ | |  | | | |    | |  | |__   ")
print("                 |  __|   > < |  ___/| |   | |  | || |    | |     \___ \| |  | | | |    | |  |  __|  ")
print("                 | |____ / . \| |    | |___| |__| || |_   | |     ____) | |__| |_| |_   | |  | |____ ")
print("                 |______/_/ \_\_|_   |______\____/_____|  |_| ___|_____/_\____/|_____|__|_|__|______|")
print("                    |  _ \ \   / /   |  __ \     /\ \        / / |    |_   _| \ | |/ ____|/ ____|    ") 
print("                    | |_) \ \_/ /    | |__) |   /  \ \  /\  / /| |      | | |  \| | |  __| (___      ")
print("                    |  _ < \   /     |  _  /   / /\ \ \/  \/ / | |      | | | . ` | | |_ |\___ \     ")
print("                    | |_) | | |      | | \ \  / ____ \  /\  /  | |____ _| |_| |\  | |__| |____) |    ")
print("                    |____/  |_|      |_|  \_\/_/    \_\/  \/   |______|_____|_| \_|\_____|_____/     ")
print(line1)
print("                                         Your almost all-in one suite for exploits.")
print("                                      use in bigger terminal window for better ASCII effect ")
print("                                               Current version running: [ <b>" + suiteversion + "</b> ]")
print(line1)
metaxploit = include_lib("/lib/metaxploit.so") // fetch metaxploit lib
if not metaxploit then
	currentPath = get_shell.host_computer.current_path
	metaxploit = include_lib(currentPath + "/metaxploit.so") // work around if library not in libs folder
end if
inmenu = "1"
menu = "0"
// show a menu to select the desired operation from.
// will be within a while block in the future, so you can return to the main menu after executing an operation
// if you so wish
if inmenu == "1" and menu == "0" then
	print ("Possible operations (Select number to start)")
	print ("<b>  1.)</b> Target probing\n <b> 2.)</b> Library version check (locally)\n <b> 3.)</b> Library vulnerability scan\n <b> 4.)</b> Attack remotely with probe and scan\n <b> 5.)</b> Attack remotely without probe and scan\n <b> 6.)</b> Local attack\n <b> 7.)</b> Local attack without scan\n <b> 8.)</b> Crack WiFi</b>")
	menu = user_input("> ")
	
end if
// probing script starts here 
if menu == "1" then
	
	inmenu = "0"
	print(line)
	print("Probe your target!")
	print(line)
	print("Specify target type...")
	target = user_input("Website? Y/N: ")
	
	if target == "Y" then
		domain= user_input("Domain:")
		ip = nslookup(domain) //since we can not directly probe domains, we need to first convert the domain to IP and then store it in a variable
		print("Probing " + ip + "............")
		print("Divide et impera")
		router = get_router(ip) // fetch the router 
		ports = router.used_ports // fetch all ports used on router
		print ("Probe Complete - Open Ports:")
		print (line)
		if not ports then print("PORTS NOT FOUND.....") //<----questionable, but included
		for port in ports
			print("Port#: " + port.port_number + " - " + router.port_info(port)) //<---- print our result
		end for
		print (line)
		inmenu = "1"
		
	else
		
		ip = user_input("Target IP: ")
		
		print("Probing " + ip + "............")
		print("Divide et impera")
		if not is_valid_ip(ip) then exit ("Probe Failed: Invalid IP") //check if the IP is in fact a valid IP, if not, we get prompted it's not valid
		
		router = get_router(ip) // fetch routher
		if not router then exit("Probe Failed: Unable to find specified router") // check if we can find a router with the IP
		
		ports = router.used_ports // fetch all ports used on router
		print ("Probe Complete - Open Ports:")
		print (line)
		if not ports then print("PORTS NOT FOUND.....") // check if we can find any ports on the IP
		
		for port in ports // loop to continiously look for ports
			print("Port#: " + port.port_number + " - " + router.port_info(port)) // print our result
		end for // break up the loop here
		print (line)
	end if
end if
end if
end if
end if

// library version checker

if menu == "2" then
	checkinputOK = false
	while (not checkinputOK)
		print(line)
		print("Running library version checker")
		print(line)
		libtoscan = user_input("Which library to scan? (ssh, smtp, http, ftp, sql, init, net, kernel)")
		libtoscan = libtoscan.replace("ssh", "/lib/libssh.so") 
		libtoscan = libtoscan.replace("smtp", "/lib/libsmtp.so")
		libtoscan = libtoscan.replace("http", "/lib/libhttp.so")
		libtoscan = libtoscan.replace("ftp", "/lib/libftp.so")
		libtoscan = libtoscan.replace("sql", "/lib/libsql.so")
		libtoscan = libtoscan.replace("init", "/lib/init.so")
		libtoscan = libtoscan.replace("net", "/lib/net.so")
		libtoscan = libtoscan.replace("kernel", "/lib/kernel_module.so")
		metaLib = metaxploit.load(libtoscan)
		file = get_shell.host_computer.File(libtoscan)
		if file == null then // if not, you're fucked
			print (libtoscan + " : " + "No such file or directory")
		else
			scanresult = metaLib.version
			print("Version is: " + scanresult)
			if user_input("Check more library versions? Y/N: " ) == "N" then checkinputOK = true and exit ("Operation finished, closing suite")
		end if
	end while
end if

// library vulnerability scan
if menu == "3" then
	print(line)
	print("Scan for vulnerabilities in a specified library!")
	print(line)
	scanlibs = user_input("Which library to scan? (ssh, smtp, http, ftp, sql, init, net, kernel)")
	scanlibs = scanlibs.replace("ssh", "/lib/libssh.so") 
	scanlibs = scanlibs.replace("smtp", "/lib/libsmtp.so")
	scanlibs = scanlibs.replace("http", "/lib/libhttp.so")
	scanlibs = scanlibs.replace("ftp", "/lib/libftp.so")
	scanlibs = scanlibs.replace("sql", "/lib/libsql.so")
	scanlibs = scanlibs.replace("init", "/lib/init.so")
	scanlibs = scanlibs.replace("net", "/lib/net.so")
	scanlibs = scanlibs.replace("kernel", "/lib/kernel_module.so")
	
	print("Trying to fetch " + scanlibs) // check if we have the target library
	file = get_shell.host_computer.File(scanlibs)
	if file == null then // if not, you're fucked
		print (scanlibs + " : " + "No such file or directory")
		
	else
		metaLib = metaxploit.load(scanlibs) // load our target library with file path as library to scan within metaxploit
		listMem = metaxploit.scan(metaLib) // start listing vulnerable  memory addresses
		print ("Scanning memory adress.....")
		index = 1
		for itemMem in listMem // for loop to actually keep checking for exploitable adresses
			print (index + ": [" + itemMem + "]")
			index = index +1
		end for // stop (for loop) right there criminal scum
	end if
	print ("Completed scan. Detected vulnerabilities in " + listMem.len + " memory zones.") // list the exploitable addresses within library's memory
	option = ""
	inputOK = false // we set input variable to null
	while (not inputOK) // defaults to 0
		option = user_input("Pick the memory index to check: ").to_int
		if typeof(option) != "number" or (option < 1 or option > listMem.len) then // if your input exceeds the listed memory, isn't a number or is less than 1, ask for new input
			print ("Input invalid. Did you type a valid number?")
			
		else 																						// if it is within valid range, start printing exploitable values for respective adress
			print("Scanning for vulnerabilities in: " + listMem[option - 1])
			print(metaxploit.scan_address(metaLib, listMem[option - 1]))
			if user_input("Continue scanning? Y/N:" ) == "N" then inputOK = true and exit ("Operation finished, closing suite") // Finish up or check for more shit to exploit.
		end if
	end while
end if

// start everything in order, except library check. First we probe for ports/services:
if menu == "4" then 
	print(line)
	print("Preparing attack sequence...")
	print(line)
	print("Specify target type...")
	target = user_input("Website? Y/N: ")
	
	if target == "Y" then
		domain= user_input("Domain:")
		ip = nslookup(domain) //since we can not directly probe domains, we need to first convert the domain to IP and then store it in a variable
		print("Probing " + ip + "............")
		print("Divide et impera")
		router = get_router(ip) // fetch the router 
		ports = router.used_ports // fetch all ports used on router
		print ("Probe Complete - Open Ports:")
		print (line)
		if not ports then print("PORTS NOT FOUND.....") //<----questionable, but included
		for port in ports
			print("Port#: " + port.port_number + " - " + router.port_info(port) + "Server") //<---- print our result
		end for
		print (line)
	end if
	
	if target == "N" then
		
		ip = user_input("Target IP: ")
		print("Probing " + ip + "............")
		print("Divide et impera")
		if not is_valid_ip(ip) then exit ("Probe Failed: Invalid IP") //check if the IP is in fact a valid IP, if not, we get prompted it's not valid
		
		router = get_router(ip) // fetch routher
		if not router then exit("Probe Failed: Unable to find specified router") // check if we can find a router with the IP
		
		ports = router.used_ports // fetch all ports used on router
		print ("Probe Complete - Open Ports:")
		print (line)
		if not ports then print("PORTS NOT FOUND.....") // check if we can find any ports on the IP
		
		for port in ports // loop to continiously look for ports
			print("Port#: " + port.port_number + " - " + router.port_info(port)) // print our result
		end for // break up the loop here
		print (line)
	end if
	
	
	option = ""
	inputisOK = null
	while inputisOK == null
		
		option = user_input("Port to attack : ")
		print ("Acquired port: " + option + " to attack")
		portcheck = user_input("Is this port correct? (Y/N): ") // did we select the right port?
		
		if portcheck == "N" then
			print ("Pick another port")
			
		else
			attackport = option 
			inputisOK = true // we are storing the selected port for the actual attack
		end if
	end while
	
	print(line)
	print("Which service to scan for vulnerabilities? (ssh, smtp, http, ftp, sql, net, init, kernel)")
	scanlibs = user_input("Pick your poison: ")
	scanlibs = scanlibs.replace("ssh", "/lib/libssh.so") 
	scanlibs = scanlibs.replace("smpt", "/lib/libsmtp.so")
	scanlibs = scanlibs.replace("http", "/lib/libhttp.so")
	scanlibs = scanlibs.replace("ftp", "/lib/libftp.so")
	scanlibs = scanlibs.replace("sql", "/lib/libsql.so")
	scanlibs = scanlibs.replace("init", "/lib/init.so")
	scanlibs = scanlibs.replace("net", "/lib/init.so")
	scanlibs = scanlibs.replace("kernel", "/lib/init.so")
	
	print("Trying to fetch " + scanlibs)
	file = get_shell.host_computer.File(scanlibs)
	if file == null then 
		print (scanlibs + " : " + "No such file or directory")
		
	else
		metaLib = metaxploit.load(scanlibs)
		scanresult = metaLib.version
		print("Local version is: " + scanresult)
		print(line)
		metaLib = metaxploit.load(scanlibs)
		listMem = metaxploit.scan(metaLib)
		print ("Scanning memory adress.....")
		index = 1
		for itemMem in listMem
			print (index + ": [" + itemMem + "]")
			index = index +1
		end for
	end if
	print ("Completed scan. Detected vulnerabilities in " + listMem.len + " memory zones.")
	option = ""
	inputOK = false
	while (not inputOK)
		option = user_input("Pick the memory index to check: ").to_int
		if typeof(option) != "number" or (option < 1 or option > listMem.len) then
			print ("Input invalid. Did you type a valid number?")
			
		else 
			print("Scanning for vulnerabilities in: " + listMem[option - 1])
			print(metaxploit.scan_address(metaLib, listMem[option - 1]))
			if user_input("Continue scanning? Y/N:" ) == "N" then inputOK = true
		end if
	end while
	
	// we are now finalizing the attack setup
	// declare our target address and port via previous user inputs, declare memory and corresponding value by user input based on previous library scan
	print (line)
	print ("Acquired target IP and Port, information about vulnerability needed")
	print (line)
	memory = user_input("Memory adress to exploit: ")
	value = user_input("Vulnerability value: ") 
	address = ip
	port = attackport.to_int
	
	net_session = metaxploit.net_use( address, port ) // attempt to establish a net session with given values
	if not net_session then exit("Error: unable to connect to net session. Closing.") // check if we can establish connection
	metaLib = net_session.dump_lib
	result = metaLib.overflow( memory, value ) // start buffer overflow on vulnerable memory with given value
	if not result then exit("Terminating operation")
	
	if typeof(result) == "shell" then
		print("Attack success, shell established.")
		result.start_terminal
		
	else if typeof(result) =="computer" then             // if we don't get shell, we can still grab as many valuables as possible
		print("Unable to get shell, grabbing valuables from " + result + " instead")
		pass = result.File("/etc/passwd") // fetch passwords of users
		print( "Decrypted password(s) found: " + pass.content)
		
		home = result.File("/home") // fetch all home folders for further use
		users = home.get_folders
		
		if users then
			print(typeof(users))
			if typeof(users) == "string" then users = [users] // create a list of users
			for user in users // loop all users in this list
				bank = result.file("/home/" + user.name + "/Config/Bank.txt")
				print(bank.content)
			end for
		end if
	else
		print("Expected shell, obtained: " + result)
		exit ("Operation finished, closing suite")
	end if
end if
end if
end if
end if
end if
end if
end if

// straight up just attack a target without any previous setup, requires more user input AND requires to know the memory zones plus exploitable value
// useful if you already acquired everything or wanna skip the entire other process


if menu == "5" then
	
	print (line)
	print ("Starting attack sequence without previous setup...")
	print (line)
	address = user_input("Target IP: ")
	port = user_input("Target port: ").to_int
	memory = user_input("Memory adress to exploit: ")
	value = user_input("Vulnerability value: ") 
	
	net_session = metaxploit.net_use( address, port )
	if not net_session then exit("Error: unable to connect to net session. Closing.")
	metaLib = net_session.dump_lib
	result = metaLib.overflow( memory, value )
	if not result then exit("Terminating operation")
	
	// check which type of results we are getting and either connect or fetch shit
	
	if typeof(result) == "shell" then
		print("Attack success, shell established.")
		result.start_terminal
	else if typeof(result) =="computer" then // if we don't get shell, we can still grab as many valuables as possible
		print("Unable to get shell, grabbing valuables from " + result + " instead")
		pass = result.File("/etc/passwd") // fetch passwords of users
		print( "Decrypted password(s) found: " + pass.content)
		
		home = result.File("/home") // fetch all home folders for further use
		users = home.get_folders
		
		if users then
			print(typeof(users))
			if typeof(users) == "string" then users = [users] // create a list of users
			for user in users // loop all users in this list
				bank = result.file("/home/" + user.name + "/Config/Bank.txt")
				print(bank.content)
			end for
		end if
	end if
	exit ("Operation finished, closing suite")
	
end if
// local attack scan

if menu == "6" then
	
	print(line)
	print("Running local attack with memory vulnerability scan")
	print(line)
	liblocal=user_input("Which library to attack? init, net, kernel >")
	liblocal = liblocal.replace("init", "/lib/init.so")
	liblocal = liblocal.replace("net", "/lib/init.so")
	liblocal = liblocal.replace("kernel", "/lib/init.so")
	
	print("Trying to fetch " + liblocal) // check if we have the target library
	file = get_shell.host_computer.File(liblocal)
	if file == null then // if not, you're fucked
		print (liblocal + " : " + "No such file or directory")
		
	else
		metaLib = metaxploit.load(liblocal) // load our target library with file path as library to scan within metaxploit
		listMem = metaxploit.scan(metaLib) // start listing vulnerable  memory addresses
		print ("Scanning memory adress.....")
		index = 1
		for itemMem in listMem // for loop to actually keep checking for exploitable adresses
			print (index + ": [" + itemMem + "]")
			index = index +1
		end for // stop (for loop) right there criminal scum
	end if
	print ("Completed scan. Detected vulnerabilities in " + listMem.len + " memory zones.") // list the exploitable addresses within library's memory
	option = ""
	inputOK = false // we set input variable to null
	while (not inputOK) // defaults to 0
		option = user_input("Pick the memory index to check: ").to_int
		if typeof(option) != "number" or (option < 1 or option > listMem.len) then // if your input exceeds the listed memory, isn't a number or is less than 1, ask for new input
			print ("Input invalid. Did you type a valid number?")
			
		else 																						// if it is within valid range, start printing exploitable values for respective adress
			print("Scanning for vulnerabilities in: " + listMem[option - 1])
			print(metaxploit.scan_address(metaLib, listMem[option - 1]))
			if user_input("Continue scanning? Y/N:" ) == "N" then inputOK = true
		end if
	end while
	
	memory = user_input("Memory adress to attack ")
	value = user_input("Value to exploit on adress " + memory)
    passinject = user_input("Try injecting new password? Y/N: ")

if passinject == "Y" then
newPass = user_input("Specify new password: ")
result = metaLib.overflow(memory, value, newPass)
if not result then exit ("Unsuccessful password injection. Closing. ")

end if 

if passinject =="N" then


	result = metaLib.overflow(memory, value)
	if not result then exit("Exploit unsuccessful. Program ending")
	
	if typeof(result) == "shell" then  // do we have shell?
		print("Success! Initiating shell...")
		result.start_terminal  // start terminal if we do
		
	else if typeof(result) == "computer" then // do we have computer?
		print("Unable to get shell, got" + result + "instead. Fetching passwords...")
		pass = result.File("/etc/passwd")    // fetch passwords and print afterwards (as decrypted)
		print( "Decrypted password(s) found: " + pass.content)
		
		print( "Fetching home folders...")
		home = result.File("/home")  // get all folders in /home/ for as many users as we can get
		users = home.get_folders
		
		if users then
			print(typeof(users))
			if typeof(users) == "string" then users = [users] // create a list of users
			for user in users // loop all users in this list
				bank = result.file("/home/" + user.name + "/Config/Bank.txt") // grab bank info 
				print(bank.content)
			end for
		end if
	end if
end if


end if
end if

// local attack no scan

if menu =="7" then
	
	print(line)
	print("Running local attack without memory scan")
	print(line)
	liblocal=user_input("Which library to attack? init, net, kernel >")
	liblocal = liblocal.replace("init", "/lib/init.so")
	liblocal = liblocal.replace("net", "/lib/init.so")
	liblocal = liblocal.replace("kernel", "/lib/init.so")
	metaLib = metaxploit.load(liblocal)
	
	memory = user_input("Memory adress to attack ")
	value = user_input("Value to exploit on adress " + memory )
    passinject = user_input("Try injecting new password? Y/N: ")

if passinject == "Y" then
newPass = user_input("Specify new password: ")
result = metaLib.overflow(memory, value, newPass)
if not result then exit ("Unsuccessful password injection. Closing. ")

end if 

if passinject =="N" then

	result = metaLib.overflow(memory, value)
	if not result then exit("Exploit unsuccessful. Program ending")
	
	if typeof(result) == "shell" then  // do we have shell?
		print("Success! Initiating shell...")
		result.start_terminal  // start terminal if we do
		
	else if typeof(result) == "computer" then // do we have computer?
		print("Unable to get shell, got" + result + "instead. Fetching passwords...")
		pass = result.File("/etc/passwd")    // fetch passwords and print afterwards (as decrypted)
		print( "Decrypted password(s) found: " + pass.content)
		
		print( "Fetching home folders...")
		home = result.File("/home")  // get all folders in /home/ for as many users as we can get
		users = home.get_folders
		
		if users then
			print(typeof(users))
			if typeof(users) == "string" then users = [users] // create a list of users
			for user in users // loop all users in this list
				bank = result.file("/home/" + user.name + "/Config/Bank.txt") // grab bank info 
				print(bank.content)
			end for
		end if
	end if
end if
end if

// wifi cracker implementation

if menu == "8" then
	print(line)      
	print("Loading up WiFi cracker")
	print(line)
	crypto = include_lib("/lib/crypto.so") // load up crypto with library
	if not crypto then // check if we  can fetch it from somewhere else..
		crypto = include_lib("crypto.so")
		if not crypto then exit("Missing crypto library, shutting down operation")
		
	end if
	// declare our own computer and the interface, takes eth0 by default, will be updated for dynamic use if we can have more than one interface.
	hostPC = get_shell.host_computer
	interface = "eth0"
	
	if not crypto.airmon("start", interface) then exit ("Can not start monitoring on " + interface)
	
	print("Targets found.")
	print(line)
	
	networks = hostPC.wifi_networks(interface)
	
	if not networks then exit("Unable to fetch networks list...")
	
	// show potential targets
	
	print("Available networks:")
	print("#       BSSID            ESSID Strength")
	i = 1
	
	//for loop to split certaing things of the WifI networks up
	for network in networks
		split = network.split(" ")
		bssid = split[0]
		strength = split[1]
		essid = split[2]
		
		print(line)
		print(i + ": <b>aireplay -b " + bssid + " -e " + essid + "</b> (" + strength + ")")
		i = i + 1
	end for
	
	// slect our target to crack
	networkToCrack = "0"
	netprompt = "Select the network you want to target, from 1 to " + networks.len + ":"
	while networkToCrack.val >= network.len or networkToCrack <=0
		networkToCrack = user_input(netprompt)
	end while 
	print(line)
	// start dirty workaround until we can actually automate ACK capturing...
	networkToCrack = networkToCrack.val - 1
	user_input("Locking on network. Use <b>aireplay</b> in another terminal window to capture at least 7000 ACKs, when done, close the other terminal window and hit enter in this one.")
	// end dirty workaround when user inputs something
	
	if not crypto.airmon("stop", interface) then exit("Unable to stop monitoring on " + interface)
	print("Monitoring stopped")
	print(line)
	
	capfilepath = home_dir + "/file.cap" // store our cap file's path 
	capfile = hostPC.File(capfilepath)    // store the actual cap file for use with automation below
	
	if not capfile then exit("Cap file is missing. Did you run aireplay?") //  check if cap file is missing
	
	if not capfile.has_permission("r") then exit("Insufficient permission to open cap file for reading.") // check if we have permission to read the actual file
	
	key = crypto.aircrack(capfilepath) // storing the password created from the capfile
	
	//  check if we were even able to fetch the key
	if not key then exit("Could not crack key. Have you obtained enough ACKs and aireplayed the correct network?") 
	
	
	print("Password cracked! [ <b>" + key + "</b> ]") // displays the stored password if we got a key
	
	print("Key cracked.")
	print(line)
	
	split = networks[networkToCrack].split(" ")
	bssid = split[0]
	essid = split[2]
	status = hostPC.connect_wifi(interface, bssid, essid, key) // connect to cracked network with all information obtained previously
	print("Connecting to network " + essid) // display which WiFi we are connecting to
	
	if status == 1 then                     // check if we are connected,
		print("Connected successfully. Have fun!")
	else 
		print("Connection failed.")
	end if
	
	capfile.delete // yeet the cap file away, it is not necessary anymore after this operation is done.
	end if
